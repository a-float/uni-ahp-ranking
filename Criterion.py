from numpy.core.fromnumeric import size
from numpy.lib.function_base import select
from Node import Node
from Alternative import Alternative
import xml.etree.ElementTree as ET
import numpy as np
import math as m
import matplotlib.pyplot as plt


EVM = "EVM"
GMM = "GMM"

class Criterion(Node):
    """ represents a criterion node. Manages weights for its children using the decision matrix """

    def __init__(self, node, root):
        super().__init__(node)
        self.is_final_criterion = False  # True if it's children all are Alternatives
        self.has_custom_matrix = False  # True if the matrix is specified by the user, False if autogenerated (np.ones)
        self.is_complete = True # Basic version has complete criterion
        for cat_node in node:
            self.children.append(Criterion(cat_node, root))
        if not self.children:
            self.is_final_criterion = True
            for alt_node in root.find('alternatives'):
                self.children.append(Alternative(alt_node, self))
        
        self.additional_matrices = [] # dodatkowe macierze, ktore beda agregowane z matrix
        self.is_aggregated = True    # przy dodaniu ustawiamy na false

        # try to load the matrix. If not specified, create a default one
        loaded_matrix = self.load_matrix(root)
        if loaded_matrix is not None:
            self.matrix = loaded_matrix
            self.has_custom_matrix = True
        else:
            self.reset_matrix() # all cells = 1
        # set the children weights
        self.update_weights()

    def __repr__(self):
        return f"{self.name}: {'✓' if self.has_custom_matrix else '?'} {' | '} {'complete' if self.is_complete else 'incomplete'} {' | '} {'weight = ' + str(round(self.weight, 3))}"

    def recursive_repr(self, depth=0):
        """ used for printing the AHP tree status """
        res = self.__repr__() + '\n'
        if self.children and not self.is_final_criterion:
            criteria = list(map(lambda x: x.recursive_repr(depth + 1), self.children))
            sep = '---' * (depth + 1) + '> '
            res += sep + sep.join(criteria)
        return res


    def update_weights(self):
        if self.is_aggregated == False:
            self.aggregate()
        weights = calculate_weights(self.matrix, self.is_complete)
        for i, w in enumerate(weights):
            self.children[i].weight = w

    def get_all_scores(self):
        # get the alternative count, needed for the range
        print(self.is_aggregated)
        if self.is_aggregated == False:
            self.aggregate()
        node = self
        while not node.is_final_criterion:
            node = node.children[0]
        alt_count = len(node.children)
        # run the actual calculations
        return self.get_scores_for(list(range(alt_count)))

    def get_scores_for(self, indices):
        if self.is_aggregated == False:
            self.aggregate()
        """ performs the AHP scores calculation with respect to the self criterion """
        names = None
        if self.is_final_criterion:
            res = np.array([alt.weight for alt in self.children])[indices]
            names = [child.name for i, child in enumerate(self.children) if i in indices]
            return res, names
        else:
            res = np.zeros(len(indices))
            for criterion in self.children:
                scores, names = criterion.get_scores_for(indices)
                res += scores * criterion.weight
        return res, names

    def reset_matrix(self):
        self.matrix = np.ones((len(self.children),) * 2)
        self.has_custom_matrix = False
        self.update_weights()

    def input_matrix(self):
        """ reads the new decision matrix values from the user via the command line """
        child_count = len(self.children)
        for i in range(0, child_count):
            for j in range(i + 1, child_count):
                msg = f"How do you compare {self.children[i].name} to {self.children[j].name} with respect to {self.name}?"
                msg += f"\n(Previously {self.matrix[i][j]})\n> "
                while True:
                    try:
                        raw_value = input(msg)
                        value = float(raw_value)
                        assert 0 <= abs(value) <= 9, "Number out of range [-9, 0) u (0, 9]"
                        if 0 < abs(value) <= 9:
                            if value < 0:
                                value = (1 / -value)
                            elif value == 0:
                                self.matrix[i][j] = value
                                self.matrix[j][i] = value
                            else:
                                self.matrix[i][j] = value
                                self.matrix[j][i] = 1 / value
                            break

                    except (AssertionError, ValueError) as e:
                        print("Invalid input: " + str(e))
        self.has_custom_matrix = True
        self.update_weights()
        print(f"Weights for criterion {self.name} has been set")

    def load_additional(self, filename):
        if self.matrix is None:
            print("use load-matrix first\n")
            return None
        try:
            tree = ET.parse(filename)
            root = tree.getroot()
        except (FileNotFoundError, ET.ParseError) as e:
            raise ValueError("Exception while loading additional file:" + str(e))
        """ returns a matrix for the criterion name read from the xml file, returns None if the matrix doesn't exist """
        matrix_node = root.find(f'.//matrix[@for="{self.name}"]')
        if matrix_node is None:
            return None
        y, x = list(map(int, [matrix_node.get('height'), matrix_node.get('width')]))
        if x != y or x != len(self.children):
            print(f"Invalid matrix size for {self.name}")
            return None
        matrix = np.ones((y, x), dtype=np.float64)
        for value in matrix_node:
            x, y = list(map(int, [value.get('x'), value.get('y')]))
            val = float(value.text)
            if val == 0:
                self.is_complete = False
            val = -(1 / val) if val < 0 else val
            if x < 0 or x > len(self.children) or y < 0 or y > len(self.children):
                print(f"Invalid attributes for value: <value x='{x}' y='{y}'>{value.text}</value> in matrix for {self.name}")
                return None
            if val == 0:
                matrix[y, x] = 0
                matrix[x, y] = 0
            else:
                matrix[y, x] = 1 / val
                matrix[x, y] = val
        print(f"# Loaded matrix for {self.name}")
        self.additional_matrices.append(matrix)
        self.is_aggregated = False

    def aggregate(self):  
        print("AGGREGATING\n")
        x = len(self.matrix)
        y =x
        for matrix_add in self.additional_matrices:
            for i in range(0,x):
                for j in range(0,y):
                    self.matrix[i][j] *= matrix_add[i][j]
        r = len(self.additional_matrices) + 1
        for i in range(0,x):
                for j in range(0,y):
                    self.matrix[i][j] = m.pow(self.matrix[i][j], 1/r)
        self.is_aggregated = True
        self.additional_matrices = []
        print(self.matrix)


    def load_matrix(self, root):
        """ returns a matrix for the criterion name read from the xml file, returns None if the matrix doesn't exist """
        matrix_node = root.find(f'.//matrix[@for="{self.name}"]')
        if matrix_node is None:
            return None
        y, x = list(map(int, [matrix_node.get('height'), matrix_node.get('width')]))
        if x != y or x != len(self.children):
            print(f"Invalid matrix size for {self.name}")
            return None
        matrix = np.ones((y, x), dtype=np.float64)
        for value in matrix_node:
            x, y = list(map(int, [value.get('x'), value.get('y')]))
            val = float(value.text)
            if val == 0:
                self.is_complete = False
            val = -(1 / val) if val < 0 else val
            if x < 0 or x > len(self.children) or y < 0 or y > len(self.children):
                print(f"Invalid attributes for value: <value x='{x}' y='{y}'>{value.text}</value> in matrix for {self.name}")
                return None
            if val == 0:
                matrix[y, x] = 0
                matrix[x, y] = 0
            else:
                matrix[y, x] = 1 / val
                matrix[x, y] = val
        print(f"# Loaded matrix for {self.name}")
        return matrix

    def find_criterion(self, name):
        """ recursively searches for the criterion with the specified name among it's children """
        if self.name == name:
            return self
        if not self.children or self.is_final_criterion:
            return None
        else:
            results = ([node.find_criterion(name) for node in self.children])
            return next((item for item in results if item is not None), None)

    def create_matrix_node_at(self, node):
        """ creates a matrix node in the specified node of the etree with the decision matrix data """
        new_matrix = ET.SubElement(node, 'matrix')
        new_matrix.set('for', self.name)
        x, y = self.matrix.shape
        new_matrix.set('width', str(x))
        new_matrix.set('height', str(y))
        for i in range(0, y - 1):
            for j in range(i + 1, x):
                value = ET.SubElement(new_matrix, 'value')
                value.set('x', str(j))
                value.set('y', str(i))
                value.text = str(self.matrix[i, j])

    def save_decision_matrix(self, data_node):
        """
        updates the etree matrix node for this criterion. Removes the current one and creates one with the
        current matrix data instead if self.has_custom_node == True
        """
        matrix = data_node.find(f"./matrix[@for='{self.name}']")
        if matrix:
            data_node.remove(matrix)
        if self.has_custom_matrix:
            self.create_matrix_node_at(data_node)
            if not self.is_final_criterion:
                for child in self.children:
                    child.save_decision_matrix(data_node)
    
    def ic(self): 
        if self.is_aggregated == False:
            self.aggregate()
        # inconsistancy + consistancy ratio
        RI = {3:0.546, 4:0.83, 5:1.08, 6:1.26,7:1.33,8:1.41,9:1.45,10:1.47,11:1.51,12:1.54,13:1.55,14:1.57,15:1.58,16:1.69,17:1.61,18:1.61,18:1.61,19:1.62,20:1.63}
        '''
        są dwie metody dla macierzy kompletnych i jedna dla niekompletnych
        '''
        if self.is_complete:
            print("COMPLETE MATRIX INCONSISTANCY INDEX CALCUATION\n")
            method = input("METHOD = [SCI/GW] ")
            if method == "SCI":
                # Saaty's consistancy index
                eigenvalues, eigenvector = map(np.real, np.linalg.eig(self.matrix))
                lambda_max = np.amax(eigenvalues)
                n = len(self.matrix)
                CI = (lambda_max - n)/(n-1)
                print("Inconsistancy = " + str(CI))
            elif method == "GW":
                # Golden Wang index
                n = len(self.matrix)
                _C = np.zeros((n,n), dtype=np.float64)
                sm = 0
                for i in range(n):
                    for j in range(n):
                        for k in range(n):
                            sm += self.matrix[k][j]
                        _C[i][j] = self.matrix[i][j]/sm
                # 6.15 126
                wgm = np.zeros(n,dtype=np.float64)
                for i in range(n):
                    licz = self.wgmu(i,n)
                    mian = 0
                    for j in range(n):
                        mian += self.wgmu(j,n)
                    wgm[i] = licz/mian
                CI = 0
                smm = 0
                for i in range(n):
                    for j in range(n):
                       smm += abs(_C[i][j] - wgm[i]) 
                CI = 1/n * smm
                print("Inconsistancy = " + str(CI))
        else:
            print("INCOMPLETE MATRIX INCONSISTANCY INDEX CALCUATION\n")
            method = input("METHOD = [SH]")
            if method == "SH":
                #Saaty-Harker
                #151
                n = len(self.matrix)
                x = n
                y = n
                B = np.ones((x, y), dtype=np.float64)
                s = np.ones((x,1), dtype=np.float64)
                for i in range(0, x):
                    for j in range(0 ,y):
                        if self.matrix[i][j] == 0:
                            s[i] += 1
                for i in range(0, x):
                    for j in range(0, y):
                        if self.matrix[i][j] == 0 and i != j:
                            B[i][j] = 0
                        if self.matrix[i][j] != 0 and i != j:
                            B[i][j] = self.matrix[i][j]
                        if i == j:
                            B[i][j] = s[i]
                eigenvalues, eigenvector = map(np.real, np.linalg.eig(B))
                max_arg = np.amax(eigenvalues)
                CI = max_arg - n / (n - 1)
                print("Inconsistancy = " + str(CI))

            

        if CI is not None and n >= 3 and n <= 20:
            print("Consistancy Ratio = " + str(CI/RI.get(n)))
        else:
            print("CI is None or n < 3 and n > 20\n")

    def wgmu(self, i, n):
        res = 1
        for j in range(n):
            res *= self.matrix[i][j]
        res = res ** (1/n)
        return res


def calculate_weights(matrix, is_complete):
    if is_complete:
        method = input("COMPLETE MATRIX: method = [EVM/GMM] ")
        if method == EVM:
            """ finds the orthogonal vector of the decision matrix with maximum length """
            eigenvalues, eigenvector = map(np.real, np.linalg.eig(matrix))
            max_index = np.argmax(eigenvalues)
            weights = eigenvector[:, max_index]
            return weights / np.sum(weights)
        elif method == GMM:
            x, y = matrix.shape
            wgmu = np.ones((x,), dtype=np.float64)
            for i in range(0, x):
                for k in range(0, x):
                    wgmu[i] *= matrix[i][k]
                wgmu[i] = m.pow(wgmu[i],1/x)
            wgm = np.zeros((x,), dtype=np.float64)
            for i in range(0,x):
                suma = 0
                for j in range(0, x):
                    suma += wgmu[j]
                wgm[i] = wgmu[i]/suma
            return wgm
        else:
            print("WRONG COMMAND")
            return
    else:
        method = input("INNCOMPLETE MATRIX: method = [EVM/GMM] ")
        x, y = matrix.shape
        
        B = np.ones((x, y), dtype=np.float64)
        s = np.ones((x,1), dtype=np.float64)
        for i in range(0, x):
            for j in range(0 ,y):
                if matrix[i][j] == 0:
                    s[i] += 1


        if method == EVM:
            for i in range(0, x):
                for j in range(0, y):
                    if matrix[i][j] == 0 and i != j:
                        B[i][j] = 0
                    if matrix[i][j] != 0 and i != j:
                        B[i][j] = matrix[i][j]
                    if i == j:
                        B[i][j] = s[i] # no need to add 1, becouse we initialized vector with ones ;)
            # B*wmax = lambdamax*wmax
            eigenvalues, eigenvector = map(np.real, np.linalg.eig(B))
            max_index = np.argmax(eigenvalues)
            weights = eigenvector[:, max_index]
            return weights / np.sum(weights)


        elif method == GMM:
            for i in range(0, x):
                for j in range(0, y):
                    if matrix[i][j] == 0 and i != j:
                        B[i][j] = 1
                    if matrix[i][j] != 0 and i != j:
                        B[i][j] = 0
                    if i == j:
                        B[i][j] = x - s[i] + 1 # becouse we initialized with zeroes
            r = np.zeros((x,1), dtype=np.float64)
            for i in range(0, x):
                for j in range(0, y):
                    if matrix[i][j] != 0:
                        r[i] = m.log(matrix[i][j]) 
            B_inv = np.linalg.inv(B)
            w_log = B_inv.dot(r)
            w = np.zeros((x,1),dtype=np.float64)
            w_scaled = np.zeros((x,1),dtype=np.float64)

            for i in range(0, size(w)):
                w[i] = m.exp(w_log[i])

            for i in range(0, size(w)):
                suma = 0
                for j in range(0, size(w)):
                    suma += w[j]
                w_scaled[i] = w[i]/suma
            res = np.zeros(size(w))
            for i in range(0, size(w)):
                res[i] = w_scaled[i]
            return res
        else:
            print("WRONG COMMAND")
            return